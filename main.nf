nextflow.enable.dsl=2

log.info """
                                                                      
8 8888888888 `8.`888b           ,8' 8888888 8888888888   .8.          
8 8888        `8.`888b         ,8'        8 8888        .888.         
8 8888         `8.`888b       ,8'         8 8888       :88888.        
8 8888          `8.`888b     ,8'          8 8888      . `88888.       
8 888888888888   `8.`888b   ,8'           8 8888     .8. `88888.      
8 8888            `8.`888b ,8'            8 8888    .8`8. `88888.     
8 8888             `8.`888b8'             8 8888   .8' `8. `88888.    
8 8888              `8.`888'              8 8888  .8'   `8. `88888.   
8 8888               `8.`8'               8 8888 .888888888. `88888.  
8 888888888888        `8.`                8 8888.8'       `8. `88888. 


""".stripIndent()

workflow {

    ch_fastqs_raw = Channel
        .fromFilePairs ( "${params.fastq_dir}/*{R1,R2}*.fastq.gz", size:2 )
        //.view()

    ch_samples = Channel
        .fromPath ( params.pair_file )
        .splitCsv ( header:true, strip:true )
        .map { row -> tuple(row.specimen, row.timepoint1, row.timepoint2) }
        //.view()

    MERGE (
        ch_fastqs_raw
    )

    // Find the innoculum and build a consensus from it
    ASSEMBLE_INOC (
        MERGE.out
    )

    // Working channel that combines merged samples by the specimen ID key
    // Grouped by the everything in the sample name before a dash char (like .split('-')[0])
    grouped_ch = MERGE.out
        .groupTuple(
            size: 2)
            .map { x -> tuple(x[0], x[1][0], x[1][1]) } //unpack list into a tuple
            //.view()

    GENERATE_T1_CONSENSUS (
        grouped_ch,
        ASSEMBLE_INOC.out
    )

    LIFT_GFF (
        GENERATE_T1_CONSENSUS.out.t2_vs_t1
    )

    MAP_SECOND_TIMEPOINT (
        LIFT_GFF.out
    )

    CALL_VARIANTS (
        MAP_SECOND_TIMEPOINT.out
    )

    if (params.var_t1 == true) {

        LIFT_GFF_to_INOC (
            ASSEMBLE_INOC.out
        )

        MAP_FIRST_TIMEPOINT_VS_INOC (
            GENERATE_T1_CONSENSUS.out.t1_vs_inoc,
            ASSEMBLE_INOC.out,
            LIFT_GFF_to_INOC.out
        )

    }

}

// MERGE the paired reads together
process MERGE {

    tag "${sampleID}"

    publishDir "Merged", mode: 'copy'

    input:
    tuple val(sampleID), path(reads)

    output:
    tuple val(sample), path("${sampleID}.fastq.gz")

    script:

    sample = sampleID.tokenize('-')[0]
    """
    bbmerge.sh in=${reads[0]} in2=${reads[1]} out=${sampleID}.fastq.gz
    """
}

// process to create a consensus from the positive control innoculum then return a consensus
process ASSEMBLE_INOC {

    tag "${specimen}"

    publishDir "INOC", mode: 'symlink'

    input:
    tuple val(specimen), path(merged_fastq)

    output:
    path "${params.inoc_prefix_before_dash}.fa"

    // Config file includes the prefix used to match the inoculum sample
    when:
    specimen.contains(params.inoc_prefix_before_dash)

    // QC then map the inoculum then generate consensus
    script:

    """
    bbduk.sh -Xmx8g in=${merged_fastq} out=QC_${merged_fastq} minlen=100 hdist=2 ftm=5 maq=10
    bbmap.sh -Xmx8g ref=${params.ref_fasta} in=QC_${merged_fastq} out=${specimen}.bam maxindel=100 minid=0.9
    samtools sort -o sorted_${specimen}.bam -l 1 ${specimen}.bam
    samtools mpileup sorted_${specimen}.bam | ivar consensus -p ${params.inoc_prefix_before_dash}
    """
}

// process that will take ref GFF and ref fasta then compare new consensus to shift the annotations
// Used on the first timepoint vs inoc
process LIFT_GFF_to_INOC {

    publishDir "GFF_INOC", mode: 'Copy'

    input:
    path inoc

    output:
    path "INOC.gff3"

    script:

    """
    liftoff -g ${params.ref_GFF} -o INOC.gff3 ${inoc} ${params.ref_fasta}
    """
}

// Takes in the grouped merged fastqs then compares the sample number generated by MiSeq to compare 
// which sample is timepoint 1. This requires the sample sheet to have ordered the samples chronologically.
// Can be easily changed to match how the samples were added.
process GENERATE_T1_CONSENSUS {

    tag "${specimen}"

    publishDir "T1_Consensus", mode: 'Copy'

    // T = Timepoint1
    input:
    tuple val(specimen), path(T1), path(T2)
    each path(inocolum)

    output:
    tuple val(specimen), path(timepoint2), path("${specimen}.fa"), emit: t2_vs_t1 // for timepoint2 variant calling
    tuple val(specimen), path(timepoint1), emit: t1_vs_inoc                       // for timepoint1 variant calling

    script:

    // if the sample number for T1 is larger than T2 then we need to swap the vars for timewise comparison
    if (T1.getSimpleName().tokenize('-')[1] > T2.getSimpleName().tokenize('-')[1]) {
        timepoint1 = T2
        timepoint2 = T1
    }
    else {
        timepoint1 = T1
        timepoint2 = T2
    }

    """
    echo "${timepoint1} | ${timepoint2}"
    bbduk.sh -Xmx8g in=${timepoint1} out=QC_${timepoint1} minlen=100 hdist=2 ftm=5 maq=10
    bbmap.sh -Xmx8g ref=${params.ref_fasta} in=QC_${timepoint1} out=${specimen}.bam maxindel=100 minid=0.9
    samtools sort -o sorted_${specimen}.bam -l 1 ${specimen}.bam
    samtools mpileup sorted_${specimen}.bam | ivar consensus -p ${specimen}
    """
}

// process that will take ref GFF and ref fasta then compare new consensus to shift the annotations
process LIFT_GFF {

    publishDir "GFF_lift", mode: 'Copy'

    tag "${specimen}"

    input:
    tuple val(specimen), path(timepoint_2), path(t1_Consensus)

    output:
    tuple val(specimen), path(timepoint_2), path(t1_Consensus), path("${specimen}.gff3")

    // sometimes the liftoff program errors out unexpectedly when run in a non-containerized env.
    script:

    """
    liftoff -g ${params.ref_GFF} -o ${specimen}.gff3 ${t1_Consensus} ${params.ref_fasta}
    """
}

// Also mapping the amp3 primers we care about to use bcftools subtract
process MAP_SECOND_TIMEPOINT {

    tag "${specimen}"

    publishDir "T2_BAMs", mode: 'Copy'

    input:
    tuple val(specimen), path(timepoint_2), path(t1_Consensus), path(consensus_gff)

    output:
    tuple val(specimen), path("${specimen}_vcf_callable.bam"), path(t1_Consensus), path(consensus_gff)

    // Mapping portion that also removes the amplicon regions not represented by all samples (specified in amp_primers.fa)
    // Then it maps and removes the barcode region from the bam file and converts all the way back to a final bam file.
    script:
    """
    # Map the amp primers so we can subtract down full bam
    if [ -n "${params.amp_primers}" ]; then
        bbmap.sh ref=${t1_Consensus} in=${params.amp_primers} out=mapped_primers.bam
        bedtools bamtobed -i mapped_primers.bam > mapped_primers.bed
        awk 'BEGIN {OFS="\t"} NR==1 {chr=\$1; start=\$2; name1=\$4; score1=\$5; strand=\$6} END {print chr "\t" start "\t" \$3 "\t" name1 "\t" score1 "\t" strand}' mapped_primers.bed > primer_amplicon.bed

    fi

    # Map the second timepoint reads against time1 consensus
    bbduk.sh -Xmx8g in=${timepoint_2} out=QC_${timepoint_2} minlen=100 hdist=2 ftm=5 maq=10
    bbmap.sh -Xmx8g ref=${t1_Consensus} in=QC_${timepoint_2} out=${specimen}_full.bam maxindel=100 minid=0.9

    if [ -n "${params.amp_primers}" ]; then
        bedtools intersect -a ${specimen}_full.bam -b primer_amplicon.bed > ${specimen}_shrunk.bam
    else
        cp ${specimen}_full.bam ${specimen}_shrunk.bam
    fi

    # Remove the barcode region
    awk '\$3 == "gene" && (\$9 ~ /vpr/ || \$9 ~ /vpx/)' ${consensus_gff} | awk '{print \$1, \$4, \$5, \$7}' > vpr_vpx_coords.txt

    # awk will then search for vpr-vpx gene region and print it into a bed file.
    # It also adds a 15 bp flank to each side to remove some mapping errors near the region
    awk 'NR==1 {vpr_start=\$2; vpr_end=\$3; vpr_strand=\$4; next} 
        NR==2 {vpx_start=\$2; vpx_end=\$3; vpx_strand=\$4; 
                if (vpx_strand == "+") {
                    start = vpr_end + 1 - 15;
                    end = vpx_start - 1 + 15;
                    print \$1 "\t" start "\t" end "\t" vpx_strand
                } else {
                    start = vpx_end + 1 - 15;
                    end = vpr_start - 1 + 15;
                    print \$1 "\t" start "\t" end "\t" vpr_strand
                }
        }' vpr_vpx_coords.txt > between_vpr_vpx.bed

    bedtools subtract -a ${specimen}_shrunk.bam -b between_vpr_vpx.bed -A > ${specimen}_vcf_callable.bam 
    
    """
    // vpr-vpx gene region is specific to barcoded SIVmac239M, it should run just fine on other viral strains as the awk
    // func will return nothing and then bedtools subtract will remove nothing.
}

process CALL_VARIANTS {

    tag "${specimen}"

    input:
    tuple val(specimen), path(callable_bam), path(t1_Consensus), path(consensus_gff)

    output:
    tuple val(specimen), path("${specimen}.tsv"), path(t1_Consensus), path(consensus_gff)

    publishDir "${params.results}", mode: 'Copy'

    script:
    """
    samtools sort -o sorted_${callable_bam} -l 1 ${callable_bam}
    samtools mpileup sorted_${callable_bam} | ivar variants -r ${t1_Consensus} -p ${specimen} -g ${consensus_gff} -m 10
    """
}

// Also mapping the amp3 primers we care about to use bcftools subtract
process MAP_FIRST_TIMEPOINT_VS_INOC {

    tag "${specimen}"

    publishDir "${params.results}", mode: 'Copy'

    input:
    tuple val(specimen), path(timepoint_1)
    each path(inoc_consensus)
    each path(inoc_gff)

    output:
    tuple val(specimen), path("${specimen}_t1.tsv"), path("${specimen}_t1_vcf_callable.bam")

    // Mapping portion that also removes the amplicon regions not represented by all samples (specified in amp_primers.fa)
    // Then it maps and removes the barcode region from the bam file and converts all the way back to a final bam file.
    script:
    """

    # Map the first timepoint reads against inoc consensus
    bbduk.sh -Xmx8g in=${timepoint_1} out=QC_${timepoint_1} minlen=100 hdist=2 ftm=5 maq=10
    bbmap.sh -Xmx8g ref=${inoc_consensus} in=QC_${timepoint_1} out=${specimen}_t1_full.bam maxindel=100 minid=0.9

    # Remove the barcode region
    awk '\$3 == "gene" && (\$9 ~ /vpr/ || \$9 ~ /vpx/)' ${inoc_gff} | awk '{print \$1, \$4, \$5, \$7}' > vpr_vpx_coords.txt

    # awk will then search for vpr-vpx gene region and print it into a bed file.
    # It also adds a 15 bp flank to each side to remove some mapping errors near the region
    awk 'NR==1 {vpr_start=\$2; vpr_end=\$3; vpr_strand=\$4; next} 
        NR==2 {vpx_start=\$2; vpx_end=\$3; vpx_strand=\$4; 
                if (vpx_strand == "+") {
                    start = vpr_end + 1 - 15;
                    end = vpx_start - 1 + 15;
                    print \$1 "\t" start "\t" end "\t" vpx_strand
                } else {
                    start = vpx_end + 1 - 15;
                    end = vpr_start - 1 + 15;
                    print \$1 "\t" start "\t" end "\t" vpr_strand
                }
        }' vpr_vpx_coords.txt > between_vpr_vpx.bed

    bedtools subtract -a ${specimen}_t1_full.bam -b between_vpr_vpx.bed -A > ${specimen}_t1_vcf_callable.bam 

    samtools sort -o sorted_t1_${specimen}.bam -l 1 ${specimen}_t1_vcf_callable.bam
    samtools mpileup sorted_t1_${specimen}.bam | ivar variants -r ${inoc_consensus} -p ${specimen}_t1 -g ${inoc_gff} -m 50
    """

    // vpr-vpx gene region is specific to barcoded SIVmac239M, it should run just fine on other viral strains as the awk
    // func will return nothing and then bedtools subtract will remove nothing.
}
/*
We need to subtract the barcode region from the bam file, and 15 bp upstream and down from that. We can use the gff file to find it as it lies
betweem vpx and vpr genes. 
cy0661 only got amplicon 3 so we need to filter all vcf's down to that region.
*/